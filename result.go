// Code generated by go generate - 2018-03-26 17:30:51.350040724 +0000 UTC
package main

// imports 
import ( 
	"github.com/jackc/pgx"
 )

// interfaces

// Bool
type ResultBool interface {
	Map(func(bool))
	FoldF(func(error), func(bool))

	MapBool(func(bool) bool) ResultBool
	FoldBool(bool, func(bool) bool) bool
	FoldBoolF(func(error) bool, func(bool) bool) bool

	MapConnPool(func(bool) *pgx.ConnPool) ResultConnPool
	FoldConnPool(*pgx.ConnPool, func(bool) *pgx.ConnPool) *pgx.ConnPool
	FoldConnPoolF(func(error) *pgx.ConnPool, func(bool) *pgx.ConnPool) *pgx.ConnPool

	MapError(func(bool) error) ResultError
	FoldError(error, func(bool) error) error
	FoldErrorF(func(error) error, func(bool) error) error

	MapNode(func(bool) Node) ResultNode
	FoldNode(Node, func(bool) Node) Node
	FoldNodeF(func(error) Node, func(bool) Node) Node

	MapStore(func(bool) Store) ResultStore
	FoldStore(Store, func(bool) Store) Store
	FoldStoreF(func(error) Store, func(bool) Store) Store
 
}

// ConnPool
type ResultConnPool interface {
	Map(func(*pgx.ConnPool))
	FoldF(func(error), func(*pgx.ConnPool))

	MapBool(func(*pgx.ConnPool) bool) ResultBool
	FoldBool(bool, func(*pgx.ConnPool) bool) bool
	FoldBoolF(func(error) bool, func(*pgx.ConnPool) bool) bool

	MapConnPool(func(*pgx.ConnPool) *pgx.ConnPool) ResultConnPool
	FoldConnPool(*pgx.ConnPool, func(*pgx.ConnPool) *pgx.ConnPool) *pgx.ConnPool
	FoldConnPoolF(func(error) *pgx.ConnPool, func(*pgx.ConnPool) *pgx.ConnPool) *pgx.ConnPool

	MapError(func(*pgx.ConnPool) error) ResultError
	FoldError(error, func(*pgx.ConnPool) error) error
	FoldErrorF(func(error) error, func(*pgx.ConnPool) error) error

	MapNode(func(*pgx.ConnPool) Node) ResultNode
	FoldNode(Node, func(*pgx.ConnPool) Node) Node
	FoldNodeF(func(error) Node, func(*pgx.ConnPool) Node) Node

	MapStore(func(*pgx.ConnPool) Store) ResultStore
	FoldStore(Store, func(*pgx.ConnPool) Store) Store
	FoldStoreF(func(error) Store, func(*pgx.ConnPool) Store) Store
 
}

// Error
type ResultError interface {
	Map(func(error))
	FoldF(func(error), func(error))

	MapBool(func(error) bool) ResultBool
	FoldBool(bool, func(error) bool) bool
	FoldBoolF(func(error) bool, func(error) bool) bool

	MapConnPool(func(error) *pgx.ConnPool) ResultConnPool
	FoldConnPool(*pgx.ConnPool, func(error) *pgx.ConnPool) *pgx.ConnPool
	FoldConnPoolF(func(error) *pgx.ConnPool, func(error) *pgx.ConnPool) *pgx.ConnPool

	MapError(func(error) error) ResultError
	FoldError(error, func(error) error) error
	FoldErrorF(func(error) error, func(error) error) error

	MapNode(func(error) Node) ResultNode
	FoldNode(Node, func(error) Node) Node
	FoldNodeF(func(error) Node, func(error) Node) Node

	MapStore(func(error) Store) ResultStore
	FoldStore(Store, func(error) Store) Store
	FoldStoreF(func(error) Store, func(error) Store) Store
 
}

// Node
type ResultNode interface {
	Map(func(Node))
	FoldF(func(error), func(Node))

	MapBool(func(Node) bool) ResultBool
	FoldBool(bool, func(Node) bool) bool
	FoldBoolF(func(error) bool, func(Node) bool) bool

	MapConnPool(func(Node) *pgx.ConnPool) ResultConnPool
	FoldConnPool(*pgx.ConnPool, func(Node) *pgx.ConnPool) *pgx.ConnPool
	FoldConnPoolF(func(error) *pgx.ConnPool, func(Node) *pgx.ConnPool) *pgx.ConnPool

	MapError(func(Node) error) ResultError
	FoldError(error, func(Node) error) error
	FoldErrorF(func(error) error, func(Node) error) error

	MapNode(func(Node) Node) ResultNode
	FoldNode(Node, func(Node) Node) Node
	FoldNodeF(func(error) Node, func(Node) Node) Node

	MapStore(func(Node) Store) ResultStore
	FoldStore(Store, func(Node) Store) Store
	FoldStoreF(func(error) Store, func(Node) Store) Store
 
}

// Store
type ResultStore interface {
	Map(func(Store))
	FoldF(func(error), func(Store))

	MapBool(func(Store) bool) ResultBool
	FoldBool(bool, func(Store) bool) bool
	FoldBoolF(func(error) bool, func(Store) bool) bool

	MapConnPool(func(Store) *pgx.ConnPool) ResultConnPool
	FoldConnPool(*pgx.ConnPool, func(Store) *pgx.ConnPool) *pgx.ConnPool
	FoldConnPoolF(func(error) *pgx.ConnPool, func(Store) *pgx.ConnPool) *pgx.ConnPool

	MapError(func(Store) error) ResultError
	FoldError(error, func(Store) error) error
	FoldErrorF(func(error) error, func(Store) error) error

	MapNode(func(Store) Node) ResultNode
	FoldNode(Node, func(Store) Node) Node
	FoldNodeF(func(error) Node, func(Store) Node) Node

	MapStore(func(Store) Store) ResultStore
	FoldStore(Store, func(Store) Store) Store
	FoldStoreF(func(error) Store, func(Store) Store) Store
 
}


// functions 

func ResultBoolFrom(v bool, err error) ResultBool {
	if err != nil {
		return ErrBool(err)
	}
	return OkBool(v)
}

func ResultConnPoolFrom(v *pgx.ConnPool, err error) ResultConnPool {
	if err != nil {
		return ErrConnPool(err)
	}
	return OkConnPool(v)
}

func ResultErrorFrom(v error, err error) ResultError {
	if err != nil {
		return ErrError(err)
	}
	return OkError(v)
}

func ResultNodeFrom(v Node, err error) ResultNode {
	if err != nil {
		return ErrNode(err)
	}
	return OkNode(v)
}

func ResultStoreFrom(v Store, err error) ResultStore {
	if err != nil {
		return ErrStore(err)
	}
	return OkStore(v)
}



// none
type errBool struct{
	left error
}

func ErrBool(err error) ResultBool {
	return errBool{err}
}

// map ErrBool
func (e errBool) Map(f func(bool)) {}
func (e errBool) FoldF(l func(e error), r func(bool)) { l(e.left) }

 // map ErrBool => ResultBool
func (e errBool) MapBool(f func(v bool) bool) ResultBool {
	return ErrBool(e.left)
}
// fold ErrBool => Resultbool
func (e errBool) FoldBool(a bool, f func(v bool) bool) bool {
	return a
}
func (e errBool) FoldBoolF(a func(error) bool, f func(bool) bool) bool {
	return a(e.left)
}

 // map ErrBool => ResultConnPool
func (e errBool) MapConnPool(f func(v bool) *pgx.ConnPool) ResultConnPool {
	return ErrConnPool(e.left)
}
// fold ErrBool => Result*pgx.ConnPool
func (e errBool) FoldConnPool(a *pgx.ConnPool, f func(v bool) *pgx.ConnPool) *pgx.ConnPool {
	return a
}
func (e errBool) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(bool) *pgx.ConnPool) *pgx.ConnPool {
	return a(e.left)
}

 // map ErrBool => ResultError
func (e errBool) MapError(f func(v bool) error) ResultError {
	return ErrError(e.left)
}
// fold ErrBool => Resulterror
func (e errBool) FoldError(a error, f func(v bool) error) error {
	return a
}
func (e errBool) FoldErrorF(a func(error) error, f func(bool) error) error {
	return a(e.left)
}

 // map ErrBool => ResultNode
func (e errBool) MapNode(f func(v bool) Node) ResultNode {
	return ErrNode(e.left)
}
// fold ErrBool => ResultNode
func (e errBool) FoldNode(a Node, f func(v bool) Node) Node {
	return a
}
func (e errBool) FoldNodeF(a func(error) Node, f func(bool) Node) Node {
	return a(e.left)
}

 // map ErrBool => ResultStore
func (e errBool) MapStore(f func(v bool) Store) ResultStore {
	return ErrStore(e.left)
}
// fold ErrBool => ResultStore
func (e errBool) FoldStore(a Store, f func(v bool) Store) Store {
	return a
}
func (e errBool) FoldStoreF(a func(error) Store, f func(bool) Store) Store {
	return a(e.left)
}
 // end of nones

// ok
type okBool struct {
	right bool
}

func OkBool(v bool) okBool {
	return okBool{v}
}
// map ErrBool
func (s okBool) Map(f func(bool)) { f(s.right) }
func (s okBool) FoldF(l func(error), r func(bool)) { r(s.right) }

// map SoneBool => ResultBool
func (s okBool) MapBool(f func(bool) bool) ResultBool {
	return OkBool(f(s.right))
}
// fold OkBool => bool
func (s okBool) FoldBool(a bool, f func(bool) bool) bool {
	return f(s.right)
}
func (s okBool) FoldBoolF(a func(error) bool, f func(bool) bool) bool {
	return f(s.right)
}

// map SoneBool => ResultConnPool
func (s okBool) MapConnPool(f func(bool) *pgx.ConnPool) ResultConnPool {
	return OkConnPool(f(s.right))
}
// fold OkBool => *pgx.ConnPool
func (s okBool) FoldConnPool(a *pgx.ConnPool, f func(bool) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}
func (s okBool) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(bool) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}

// map SoneBool => ResultError
func (s okBool) MapError(f func(bool) error) ResultError {
	return OkError(f(s.right))
}
// fold OkBool => error
func (s okBool) FoldError(a error, f func(bool) error) error {
	return f(s.right)
}
func (s okBool) FoldErrorF(a func(error) error, f func(bool) error) error {
	return f(s.right)
}

// map SoneBool => ResultNode
func (s okBool) MapNode(f func(bool) Node) ResultNode {
	return OkNode(f(s.right))
}
// fold OkBool => Node
func (s okBool) FoldNode(a Node, f func(bool) Node) Node {
	return f(s.right)
}
func (s okBool) FoldNodeF(a func(error) Node, f func(bool) Node) Node {
	return f(s.right)
}

// map SoneBool => ResultStore
func (s okBool) MapStore(f func(bool) Store) ResultStore {
	return OkStore(f(s.right))
}
// fold OkBool => Store
func (s okBool) FoldStore(a Store, f func(bool) Store) Store {
	return f(s.right)
}
func (s okBool) FoldStoreF(a func(error) Store, f func(bool) Store) Store {
	return f(s.right)
}
 // end of oks


// none
type errConnPool struct{
	left error
}

func ErrConnPool(err error) ResultConnPool {
	return errConnPool{err}
}

// map ErrConnPool
func (e errConnPool) Map(f func(*pgx.ConnPool)) {}
func (e errConnPool) FoldF(l func(e error), r func(*pgx.ConnPool)) { l(e.left) }

 // map ErrConnPool => ResultBool
func (e errConnPool) MapBool(f func(v *pgx.ConnPool) bool) ResultBool {
	return ErrBool(e.left)
}
// fold ErrConnPool => Resultbool
func (e errConnPool) FoldBool(a bool, f func(v *pgx.ConnPool) bool) bool {
	return a
}
func (e errConnPool) FoldBoolF(a func(error) bool, f func(*pgx.ConnPool) bool) bool {
	return a(e.left)
}

 // map ErrConnPool => ResultConnPool
func (e errConnPool) MapConnPool(f func(v *pgx.ConnPool) *pgx.ConnPool) ResultConnPool {
	return ErrConnPool(e.left)
}
// fold ErrConnPool => Result*pgx.ConnPool
func (e errConnPool) FoldConnPool(a *pgx.ConnPool, f func(v *pgx.ConnPool) *pgx.ConnPool) *pgx.ConnPool {
	return a
}
func (e errConnPool) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(*pgx.ConnPool) *pgx.ConnPool) *pgx.ConnPool {
	return a(e.left)
}

 // map ErrConnPool => ResultError
func (e errConnPool) MapError(f func(v *pgx.ConnPool) error) ResultError {
	return ErrError(e.left)
}
// fold ErrConnPool => Resulterror
func (e errConnPool) FoldError(a error, f func(v *pgx.ConnPool) error) error {
	return a
}
func (e errConnPool) FoldErrorF(a func(error) error, f func(*pgx.ConnPool) error) error {
	return a(e.left)
}

 // map ErrConnPool => ResultNode
func (e errConnPool) MapNode(f func(v *pgx.ConnPool) Node) ResultNode {
	return ErrNode(e.left)
}
// fold ErrConnPool => ResultNode
func (e errConnPool) FoldNode(a Node, f func(v *pgx.ConnPool) Node) Node {
	return a
}
func (e errConnPool) FoldNodeF(a func(error) Node, f func(*pgx.ConnPool) Node) Node {
	return a(e.left)
}

 // map ErrConnPool => ResultStore
func (e errConnPool) MapStore(f func(v *pgx.ConnPool) Store) ResultStore {
	return ErrStore(e.left)
}
// fold ErrConnPool => ResultStore
func (e errConnPool) FoldStore(a Store, f func(v *pgx.ConnPool) Store) Store {
	return a
}
func (e errConnPool) FoldStoreF(a func(error) Store, f func(*pgx.ConnPool) Store) Store {
	return a(e.left)
}
 // end of nones

// ok
type okConnPool struct {
	right *pgx.ConnPool
}

func OkConnPool(v *pgx.ConnPool) okConnPool {
	return okConnPool{v}
}
// map ErrConnPool
func (s okConnPool) Map(f func(*pgx.ConnPool)) { f(s.right) }
func (s okConnPool) FoldF(l func(error), r func(*pgx.ConnPool)) { r(s.right) }

// map SoneConnPool => ResultBool
func (s okConnPool) MapBool(f func(*pgx.ConnPool) bool) ResultBool {
	return OkBool(f(s.right))
}
// fold OkConnPool => bool
func (s okConnPool) FoldBool(a bool, f func(*pgx.ConnPool) bool) bool {
	return f(s.right)
}
func (s okConnPool) FoldBoolF(a func(error) bool, f func(*pgx.ConnPool) bool) bool {
	return f(s.right)
}

// map SoneConnPool => ResultConnPool
func (s okConnPool) MapConnPool(f func(*pgx.ConnPool) *pgx.ConnPool) ResultConnPool {
	return OkConnPool(f(s.right))
}
// fold OkConnPool => *pgx.ConnPool
func (s okConnPool) FoldConnPool(a *pgx.ConnPool, f func(*pgx.ConnPool) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}
func (s okConnPool) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(*pgx.ConnPool) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}

// map SoneConnPool => ResultError
func (s okConnPool) MapError(f func(*pgx.ConnPool) error) ResultError {
	return OkError(f(s.right))
}
// fold OkConnPool => error
func (s okConnPool) FoldError(a error, f func(*pgx.ConnPool) error) error {
	return f(s.right)
}
func (s okConnPool) FoldErrorF(a func(error) error, f func(*pgx.ConnPool) error) error {
	return f(s.right)
}

// map SoneConnPool => ResultNode
func (s okConnPool) MapNode(f func(*pgx.ConnPool) Node) ResultNode {
	return OkNode(f(s.right))
}
// fold OkConnPool => Node
func (s okConnPool) FoldNode(a Node, f func(*pgx.ConnPool) Node) Node {
	return f(s.right)
}
func (s okConnPool) FoldNodeF(a func(error) Node, f func(*pgx.ConnPool) Node) Node {
	return f(s.right)
}

// map SoneConnPool => ResultStore
func (s okConnPool) MapStore(f func(*pgx.ConnPool) Store) ResultStore {
	return OkStore(f(s.right))
}
// fold OkConnPool => Store
func (s okConnPool) FoldStore(a Store, f func(*pgx.ConnPool) Store) Store {
	return f(s.right)
}
func (s okConnPool) FoldStoreF(a func(error) Store, f func(*pgx.ConnPool) Store) Store {
	return f(s.right)
}
 // end of oks


// none
type errError struct{
	left error
}

func ErrError(err error) ResultError {
	return errError{err}
}

// map ErrError
func (e errError) Map(f func(error)) {}
func (e errError) FoldF(l func(e error), r func(error)) { l(e.left) }

 // map ErrError => ResultBool
func (e errError) MapBool(f func(v error) bool) ResultBool {
	return ErrBool(e.left)
}
// fold ErrError => Resultbool
func (e errError) FoldBool(a bool, f func(v error) bool) bool {
	return a
}
func (e errError) FoldBoolF(a func(error) bool, f func(error) bool) bool {
	return a(e.left)
}

 // map ErrError => ResultConnPool
func (e errError) MapConnPool(f func(v error) *pgx.ConnPool) ResultConnPool {
	return ErrConnPool(e.left)
}
// fold ErrError => Result*pgx.ConnPool
func (e errError) FoldConnPool(a *pgx.ConnPool, f func(v error) *pgx.ConnPool) *pgx.ConnPool {
	return a
}
func (e errError) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(error) *pgx.ConnPool) *pgx.ConnPool {
	return a(e.left)
}

 // map ErrError => ResultError
func (e errError) MapError(f func(v error) error) ResultError {
	return ErrError(e.left)
}
// fold ErrError => Resulterror
func (e errError) FoldError(a error, f func(v error) error) error {
	return a
}
func (e errError) FoldErrorF(a func(error) error, f func(error) error) error {
	return a(e.left)
}

 // map ErrError => ResultNode
func (e errError) MapNode(f func(v error) Node) ResultNode {
	return ErrNode(e.left)
}
// fold ErrError => ResultNode
func (e errError) FoldNode(a Node, f func(v error) Node) Node {
	return a
}
func (e errError) FoldNodeF(a func(error) Node, f func(error) Node) Node {
	return a(e.left)
}

 // map ErrError => ResultStore
func (e errError) MapStore(f func(v error) Store) ResultStore {
	return ErrStore(e.left)
}
// fold ErrError => ResultStore
func (e errError) FoldStore(a Store, f func(v error) Store) Store {
	return a
}
func (e errError) FoldStoreF(a func(error) Store, f func(error) Store) Store {
	return a(e.left)
}
 // end of nones

// ok
type okError struct {
	right error
}

func OkError(v error) okError {
	return okError{v}
}
// map ErrError
func (s okError) Map(f func(error)) { f(s.right) }
func (s okError) FoldF(l func(error), r func(error)) { r(s.right) }

// map SoneError => ResultBool
func (s okError) MapBool(f func(error) bool) ResultBool {
	return OkBool(f(s.right))
}
// fold OkError => bool
func (s okError) FoldBool(a bool, f func(error) bool) bool {
	return f(s.right)
}
func (s okError) FoldBoolF(a func(error) bool, f func(error) bool) bool {
	return f(s.right)
}

// map SoneError => ResultConnPool
func (s okError) MapConnPool(f func(error) *pgx.ConnPool) ResultConnPool {
	return OkConnPool(f(s.right))
}
// fold OkError => *pgx.ConnPool
func (s okError) FoldConnPool(a *pgx.ConnPool, f func(error) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}
func (s okError) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(error) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}

// map SoneError => ResultError
func (s okError) MapError(f func(error) error) ResultError {
	return OkError(f(s.right))
}
// fold OkError => error
func (s okError) FoldError(a error, f func(error) error) error {
	return f(s.right)
}
func (s okError) FoldErrorF(a func(error) error, f func(error) error) error {
	return f(s.right)
}

// map SoneError => ResultNode
func (s okError) MapNode(f func(error) Node) ResultNode {
	return OkNode(f(s.right))
}
// fold OkError => Node
func (s okError) FoldNode(a Node, f func(error) Node) Node {
	return f(s.right)
}
func (s okError) FoldNodeF(a func(error) Node, f func(error) Node) Node {
	return f(s.right)
}

// map SoneError => ResultStore
func (s okError) MapStore(f func(error) Store) ResultStore {
	return OkStore(f(s.right))
}
// fold OkError => Store
func (s okError) FoldStore(a Store, f func(error) Store) Store {
	return f(s.right)
}
func (s okError) FoldStoreF(a func(error) Store, f func(error) Store) Store {
	return f(s.right)
}
 // end of oks


// none
type errNode struct{
	left error
}

func ErrNode(err error) ResultNode {
	return errNode{err}
}

// map ErrNode
func (e errNode) Map(f func(Node)) {}
func (e errNode) FoldF(l func(e error), r func(Node)) { l(e.left) }

 // map ErrNode => ResultBool
func (e errNode) MapBool(f func(v Node) bool) ResultBool {
	return ErrBool(e.left)
}
// fold ErrNode => Resultbool
func (e errNode) FoldBool(a bool, f func(v Node) bool) bool {
	return a
}
func (e errNode) FoldBoolF(a func(error) bool, f func(Node) bool) bool {
	return a(e.left)
}

 // map ErrNode => ResultConnPool
func (e errNode) MapConnPool(f func(v Node) *pgx.ConnPool) ResultConnPool {
	return ErrConnPool(e.left)
}
// fold ErrNode => Result*pgx.ConnPool
func (e errNode) FoldConnPool(a *pgx.ConnPool, f func(v Node) *pgx.ConnPool) *pgx.ConnPool {
	return a
}
func (e errNode) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(Node) *pgx.ConnPool) *pgx.ConnPool {
	return a(e.left)
}

 // map ErrNode => ResultError
func (e errNode) MapError(f func(v Node) error) ResultError {
	return ErrError(e.left)
}
// fold ErrNode => Resulterror
func (e errNode) FoldError(a error, f func(v Node) error) error {
	return a
}
func (e errNode) FoldErrorF(a func(error) error, f func(Node) error) error {
	return a(e.left)
}

 // map ErrNode => ResultNode
func (e errNode) MapNode(f func(v Node) Node) ResultNode {
	return ErrNode(e.left)
}
// fold ErrNode => ResultNode
func (e errNode) FoldNode(a Node, f func(v Node) Node) Node {
	return a
}
func (e errNode) FoldNodeF(a func(error) Node, f func(Node) Node) Node {
	return a(e.left)
}

 // map ErrNode => ResultStore
func (e errNode) MapStore(f func(v Node) Store) ResultStore {
	return ErrStore(e.left)
}
// fold ErrNode => ResultStore
func (e errNode) FoldStore(a Store, f func(v Node) Store) Store {
	return a
}
func (e errNode) FoldStoreF(a func(error) Store, f func(Node) Store) Store {
	return a(e.left)
}
 // end of nones

// ok
type okNode struct {
	right Node
}

func OkNode(v Node) okNode {
	return okNode{v}
}
// map ErrNode
func (s okNode) Map(f func(Node)) { f(s.right) }
func (s okNode) FoldF(l func(error), r func(Node)) { r(s.right) }

// map SoneNode => ResultBool
func (s okNode) MapBool(f func(Node) bool) ResultBool {
	return OkBool(f(s.right))
}
// fold OkNode => bool
func (s okNode) FoldBool(a bool, f func(Node) bool) bool {
	return f(s.right)
}
func (s okNode) FoldBoolF(a func(error) bool, f func(Node) bool) bool {
	return f(s.right)
}

// map SoneNode => ResultConnPool
func (s okNode) MapConnPool(f func(Node) *pgx.ConnPool) ResultConnPool {
	return OkConnPool(f(s.right))
}
// fold OkNode => *pgx.ConnPool
func (s okNode) FoldConnPool(a *pgx.ConnPool, f func(Node) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}
func (s okNode) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(Node) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}

// map SoneNode => ResultError
func (s okNode) MapError(f func(Node) error) ResultError {
	return OkError(f(s.right))
}
// fold OkNode => error
func (s okNode) FoldError(a error, f func(Node) error) error {
	return f(s.right)
}
func (s okNode) FoldErrorF(a func(error) error, f func(Node) error) error {
	return f(s.right)
}

// map SoneNode => ResultNode
func (s okNode) MapNode(f func(Node) Node) ResultNode {
	return OkNode(f(s.right))
}
// fold OkNode => Node
func (s okNode) FoldNode(a Node, f func(Node) Node) Node {
	return f(s.right)
}
func (s okNode) FoldNodeF(a func(error) Node, f func(Node) Node) Node {
	return f(s.right)
}

// map SoneNode => ResultStore
func (s okNode) MapStore(f func(Node) Store) ResultStore {
	return OkStore(f(s.right))
}
// fold OkNode => Store
func (s okNode) FoldStore(a Store, f func(Node) Store) Store {
	return f(s.right)
}
func (s okNode) FoldStoreF(a func(error) Store, f func(Node) Store) Store {
	return f(s.right)
}
 // end of oks


// none
type errStore struct{
	left error
}

func ErrStore(err error) ResultStore {
	return errStore{err}
}

// map ErrStore
func (e errStore) Map(f func(Store)) {}
func (e errStore) FoldF(l func(e error), r func(Store)) { l(e.left) }

 // map ErrStore => ResultBool
func (e errStore) MapBool(f func(v Store) bool) ResultBool {
	return ErrBool(e.left)
}
// fold ErrStore => Resultbool
func (e errStore) FoldBool(a bool, f func(v Store) bool) bool {
	return a
}
func (e errStore) FoldBoolF(a func(error) bool, f func(Store) bool) bool {
	return a(e.left)
}

 // map ErrStore => ResultConnPool
func (e errStore) MapConnPool(f func(v Store) *pgx.ConnPool) ResultConnPool {
	return ErrConnPool(e.left)
}
// fold ErrStore => Result*pgx.ConnPool
func (e errStore) FoldConnPool(a *pgx.ConnPool, f func(v Store) *pgx.ConnPool) *pgx.ConnPool {
	return a
}
func (e errStore) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(Store) *pgx.ConnPool) *pgx.ConnPool {
	return a(e.left)
}

 // map ErrStore => ResultError
func (e errStore) MapError(f func(v Store) error) ResultError {
	return ErrError(e.left)
}
// fold ErrStore => Resulterror
func (e errStore) FoldError(a error, f func(v Store) error) error {
	return a
}
func (e errStore) FoldErrorF(a func(error) error, f func(Store) error) error {
	return a(e.left)
}

 // map ErrStore => ResultNode
func (e errStore) MapNode(f func(v Store) Node) ResultNode {
	return ErrNode(e.left)
}
// fold ErrStore => ResultNode
func (e errStore) FoldNode(a Node, f func(v Store) Node) Node {
	return a
}
func (e errStore) FoldNodeF(a func(error) Node, f func(Store) Node) Node {
	return a(e.left)
}

 // map ErrStore => ResultStore
func (e errStore) MapStore(f func(v Store) Store) ResultStore {
	return ErrStore(e.left)
}
// fold ErrStore => ResultStore
func (e errStore) FoldStore(a Store, f func(v Store) Store) Store {
	return a
}
func (e errStore) FoldStoreF(a func(error) Store, f func(Store) Store) Store {
	return a(e.left)
}
 // end of nones

// ok
type okStore struct {
	right Store
}

func OkStore(v Store) okStore {
	return okStore{v}
}
// map ErrStore
func (s okStore) Map(f func(Store)) { f(s.right) }
func (s okStore) FoldF(l func(error), r func(Store)) { r(s.right) }

// map SoneStore => ResultBool
func (s okStore) MapBool(f func(Store) bool) ResultBool {
	return OkBool(f(s.right))
}
// fold OkStore => bool
func (s okStore) FoldBool(a bool, f func(Store) bool) bool {
	return f(s.right)
}
func (s okStore) FoldBoolF(a func(error) bool, f func(Store) bool) bool {
	return f(s.right)
}

// map SoneStore => ResultConnPool
func (s okStore) MapConnPool(f func(Store) *pgx.ConnPool) ResultConnPool {
	return OkConnPool(f(s.right))
}
// fold OkStore => *pgx.ConnPool
func (s okStore) FoldConnPool(a *pgx.ConnPool, f func(Store) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}
func (s okStore) FoldConnPoolF(a func(error) *pgx.ConnPool, f func(Store) *pgx.ConnPool) *pgx.ConnPool {
	return f(s.right)
}

// map SoneStore => ResultError
func (s okStore) MapError(f func(Store) error) ResultError {
	return OkError(f(s.right))
}
// fold OkStore => error
func (s okStore) FoldError(a error, f func(Store) error) error {
	return f(s.right)
}
func (s okStore) FoldErrorF(a func(error) error, f func(Store) error) error {
	return f(s.right)
}

// map SoneStore => ResultNode
func (s okStore) MapNode(f func(Store) Node) ResultNode {
	return OkNode(f(s.right))
}
// fold OkStore => Node
func (s okStore) FoldNode(a Node, f func(Store) Node) Node {
	return f(s.right)
}
func (s okStore) FoldNodeF(a func(error) Node, f func(Store) Node) Node {
	return f(s.right)
}

// map SoneStore => ResultStore
func (s okStore) MapStore(f func(Store) Store) ResultStore {
	return OkStore(f(s.right))
}
// fold OkStore => Store
func (s okStore) FoldStore(a Store, f func(Store) Store) Store {
	return f(s.right)
}
func (s okStore) FoldStoreF(a func(error) Store, f func(Store) Store) Store {
	return f(s.right)
}
 // end of oks

 // end of everything

