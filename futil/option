// Code generated by go generate - {{ .Timestamp }}
package {{ .PackageName }}

// imports 
import ({{ range $_, $package := .Imports }}
	"{{ $package }}"
{{ end }})

{{$Types := .Types}}
// interfaces
{{ range $label, $type := $Types }}
// {{ $label }}
type Option{{ $label }} interface {
	Map(func({{ $type }}))
	FoldF(func(), func({{ $type }}))
{{ range $l, $t := $Types }}
	Map{{ $l }}(func({{ $type }}) {{ $t }}) Option{{ $l }}
	Fold{{ $l }}({{ $t }}, func({{ $type }}) {{ $t }}) {{ $t }}
	Fold{{ $l }}F(func() {{ $t }}, func({{ $type }}) {{ $t }}) {{ $t }}
{{ end }} 
}
{{ end }}

// functions 
{{ range $label, $type := $Types }}
func Id{{ $label }}(v {{ $type }}) {{ $type }} {return v}
func Option{{ $label }}From(v {{ $type }}, err error) Option{{ $label }} {
	if err != nil {
		return None{{ $label }}()
	}
	return Some{{ $label }}(v)
}
{{ end }}

{{ range $label, $type := $Types }}
// none
type none{{ $label }} struct{}

func None{{ $label }}() Option{{ $label }} {
	return none{{ $label }}{}
}

// map None{{ $label }}
func (n none{{ $label }}) Map(f func({{ $type }})) {}
func (n none{{ $label }}) FoldF(l func(), r func({{ $type }})) { l() }
{{ range $l, $t := $Types }}
 // map None{{ $label }} => Option{{ $l }}
func (n none{{ $label }}) Map{{ $l }}(f func(v {{ $type }}) {{ $t }}) Option{{ $l }} {
	return none{{ $l }}{}
}
// fold None{{ $label }} => Option{{ $t }}
func (n none{{ $label }}) Fold{{ $l }}(a {{ $t }}, f func(v {{ $type }}) {{ $t }}) {{ $t }} {
	return a
}
func (n none{{ $label }}) Fold{{ $l }}F(a func() {{ $t }}, f func(v {{ $type }}) {{ $t }}) {{ $t }} {
	return a()
}
{{ end }} // end of nones

// some
type some{{ $label }} struct {
	v {{ $type }}
}

func Some{{ $label }}(v {{ $type }}) some{{ $label }} {
	return some{{ $label }}{v}
}
// map None{{ $label }}
func (s some{{ $label }}) Map(f func({{ $type }})) { f(s.v) }
func (s some{{ $label }}) FoldF(l func(), r func({{ $type }})) { r(s.v) }
{{ range $l, $t := $Types }}
// map Sone{{ $label }} => Option{{ $l }}
func (s some{{ $label }}) Map{{ $l }}(f func(v {{ $type }}) {{ $t }}) Option{{ $l }} {
	return Some{{ $l }}(f(s.v))
}
// fold Some{{ $label }} => {{ $t }}
func (s some{{ $label }}) Fold{{ $l }}(a {{ $t }}, f func(v {{ $type }}) {{ $t }}) {{ $t }} {
	return f(s.v)
}
func (s some{{ $label }}) Fold{{ $l }}F(a func() {{ $t }}, f func(v {{ $type }}) {{ $t }}) {{ $t }} {
	return f(s.v)
}
{{ end }} // end of somes

{{ end }} // end of everything

