/*
 *  Copyright (C) 2018 Pierre Marchand <pierre.m@atelier-cartographique.be>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, version 3 of the License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


// Code generated by go generate - {{ .Timestamp }}
package {{ .PackageName }}

// imports 
import (
{{ range $_, $package := .Imports }}
	"{{ $package }}"
{{ end }} )

{{$Types := .Types}}
// interfaces
{{ range $label, $type := $Types }}
// {{ $label }}
type Array{{ $label }} interface {
	First() Result{{$label}}
	Slice() array{{$label}}
	Each(func({{ $type }}))
	Concat(Array{{$label}}) Array{{$label}}
{{ range $l, $t := $Types }}
	Map{{ $l }}(func({{ $type }}) {{ $t }}) Array{{ $l }}
	Reduce{{ $l }}(func({{ $type }}, int, Array{{ $label }}) {{ $t }}, {{ $t }}) {{ $t }}
{{ end }} 
}
{{ end }} // end of interfaces



// implements
{{ range $label, $type := $Types }}

type array{{ $label }} []{{$type}}

func NewArray{{$label}}(a ...{{$type}})Array{{$label}} {
	return array{{$label}}(a)
}

func (a array{{$label}}) First() Result{{$label}} {
	if len(a) > 0 {
		return Ok{{$label}}(a[0])
	}
	return Err{{$label}}("Out Of Bound Array Access")
}


func (a array{{$label}}) Slice() array{{$label}} {
	return a
}

func (a array{{ $label }}) Each(f func({{ $type }})) {
	for _, e := range a { f(e) }
}

func (a array{{ $label }}) Concat(xs Array{{$label}}) Array{{ $label }} {
	return array{{$label}}(append(a.Slice(), xs.Slice()...))
}

{{ range $l, $t := $Types }}

func (a array{{ $label }}) Map{{ $l }}(f func({{ $type }}) {{ $t }}) Array{{ $l }} {
	var r = make(array{{$l}}, len(a))
	for i, e := range a { r[i] = f(e) }
	return array{{$l}}(r)
}

func (a array{{ $label }}) Reduce{{ $l }}(f func({{ $type }}, int, Array{{ $label }}) {{ $t }}, initial {{ $t }}) {{ $t }} {
	var r {{$t}} = initial
	for i, e := range a { 
		r = f(e, i, a)
	}
	return r
}

{{ end }} // end of {{$label}}

{{ end }} // end of implements


