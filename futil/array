// Code generated by go generate - {{ .Timestamp }}
package {{ .PackageName }}

// imports 
import ( {{ range $_, $package := .Imports }}
	"{{ $package }}"
{{ end }} )

{{$Types := .Types}}
// interfaces
{{ range $label, $type := $Types }}
// {{ $label }}
type Array{{ $label }} interface {
	Slice() array{{$label}}
	Each(func({{ $type }}))
	Concat(Array{{$label}}) Array{{$label}}
{{ range $l, $t := $Types }}
	Map{{ $l }}(func({{ $type }}) {{ $t }}) Array{{ $l }}
	Reduce{{ $l }}(func({{ $type }}, int, Array{{ $label }}) {{ $t }}, {{ $t }}) {{ $t }}
{{ end }} 
}
{{ end }} // end of interfaces



// implements
{{ range $label, $type := $Types }}

type array{{ $label }} []{{$type}}

func NewArray{{$label}}(a []{{$type}})Array{{$label}} {
	return array{{$label}}(a)
}

func (a array{{$label}}) Slice() array{{$label}} {
	return a
}

func (a array{{ $label }}) Each(f func({{ $type }})) {
	for _, e := range a { f(e) }
}

func (a array{{ $label }}) Concat(xs Array{{$label}}) Array{{ $label }} {
	return array{{$label}}(append(a.Slice(), xs.Slice()...))
}

{{ range $l, $t := $Types }}

func (a array{{ $label }}) Map{{ $l }}(f func({{ $type }}) {{ $t }}) Array{{ $l }} {
	var r = make(array{{$l}}, len(a))
	for i, e := range a { r[i] = f(e) }
	return array{{$l}}(r)
}

func (a array{{ $label }}) Reduce{{ $l }}(f func({{ $type }}, int, Array{{ $label }}) {{ $t }}, initial {{ $t }}) {{ $t }} {
	var r {{$t}} = initial
	for i, e := range a { 
		r = f(e, i, a)
	}
	return r
}

{{ end }} // end of {{$label}}

{{ end }} // end of implements


